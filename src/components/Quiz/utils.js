import { AUDIENCE_TYPES } from "./constants";

// These weights were generated by the data science team
const responseWeights = [
  [0.19661324, -0.23336114, -0.39460518, 0.4313530798], // rank_goals_1_1
  [-0.0181344, 0.17770629, -0.16040073, 0.0008288423], // rank_goals_1_2
  [-0.4526589, 0.29743149, 0.3700687, -0.2148412927], // rank_goals_1_3
  [0.34663558, -0.30528848, 0.18921721, -0.2305643158], // rank_goals_1_4
  [-0.24243695, -0.31898312, 0.17159933, 0.3898207369], // rank_goals_2_1
  [0.21508206, -0.11027478, -0.01775387, -0.0870534123], // rank_goals_2_2
  [-0.37489239, 0.45585687, 0.38485537, -0.4658198411], // rank_goals_2_3
  [0.25624749, -0.07691627, -0.37637471, 0.1970434899], // rank_goals_2_4
  [0.09186467, -0.12034109, -0.55545396, 0.5839303762], // rank_goals_3_1
  [-0.10277331, 0.36407918, -0.04802435, -0.2132815249], // rank_goals_3_2
  [0.04743451, 0.39771277, 0.22259875, -0.6677460333], // rank_goals_3_3
  [-0.03874094, -0.80230519, 0.46201467, 0.3790314558], // rank_goals_3_4
  [0.95429889, -0.19356381, -0.93471181, 0.1739767287], // rank_goals_4_1
  [0.13073653, 0.43895003, -0.13593685, -0.4337497099], // rank_goals_4_2
  [-0.84001154, -0.55523845, 0.71753857, 0.6777114168], // rank_goals_4_3
  [-0.23913441, 0.38361303, 0.37223736, -0.516715985], // rank_goals_4_4
  [0.11577981, 1.87039342, -1.16283943, -0.8233338095], //intercept
];

// The ordering here corresponds to the ordering of weights above
const responseOrder = [
  AUDIENCE_TYPES.DONT_TREAD_ON_ME,
  AUDIENCE_TYPES.IF_YOU_SAY_SO,
  AUDIENCE_TYPES.PEOPLE_POWER,
  AUDIENCE_TYPES.TOUGH_COOKIES,
];

function getConvertedValues(values) {
  return values.map((v) => {
    const out = [];
    v.forEach((val, i) => {
      out[val] = i;
    });
    return out;
  });
}

export const getQuizResult = (vals) => {
  const values = getConvertedValues(vals);
  // Calculate each response value by each column in the weights array.
  // This outputs an array of lenght 4, where the ordering of the array
  // matches responseOrder.
  const result = values.flat().reduce((acc, val, i) => {
    return [
      acc[0] + (4 - val) * responseWeights[i][0],
      acc[1] + (4 - val) * responseWeights[i][1],
      acc[2] + (4 - val) * responseWeights[i][2],
      acc[3] + (4 - val) * responseWeights[i][3],
    ];
    // Our initial values are equal to the intercept from the response
    // weights matrix. This is essentially the same as adding in the
    // weights at the beginning or end of the calculation.
  }, responseWeights[responseWeights.length - 1]);

  // Get the index of the largest value in the result array.
  let maxResponse = Number.NEGATIVE_INFINITY;
  let maxResponseIndex = -1;
  result.forEach((val, i) => {
    if (val > maxResponse) {
      maxResponse = val;
      maxResponseIndex = i;
    }
  });

  // Return the audience that maps to the largest value in the
  // result array.
  return responseOrder[maxResponseIndex];
};
